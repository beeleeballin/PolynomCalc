------------------------------------------------------------------------
This is the project README file. Here, you should describe your project.
Tell the reader (someone who does not know anything about this project)
all he/she needs to know. The comments should usually include at least:
------------------------------------------------------------------------

PROJECT TITLE: Polynomial Calculator

My polynomial class is a list of monomials, which are individual objects that hold a coefficient and an exponent value to an operand. The ArrayList framework is chosen for the polynomial object because I intended to use many get() methods in the methods for the polynomial class, and therefore it would be a wise choice when compared to the LinkedList framework. Also, I ensured that I use the add(int idx, E e) with idx = 0 as much as possible, and not the add(E e), so it takes constant time O(1). Not only does the polynomial class rely on the monomial class for the individual objects on the list, but the monomial class is also responsible for the sorting method in the polynomial class based on its Comparable interface. Besides a sorting method, other helper methods such as one that removes monomials that represent 0s, one that verifies whether a polynomial object is empty, and one that duplicates a polynomial object, work alongside or within the principle methods which add, subtract, multiply or divide one polynomial by another.

In my parsing class (FSM), my finite state machine (parsePoly()) has 11 states excluding an error state, and the above is a depiction of it. Together with the states to ensure the flow of the parsing, I have an iterator (i), a character variable (c) that saves the iterating character from the input string, a map (memory) that acquires associated polynomial expressions using characters as the key, a boolean variable (used) that stores whether there is a polynomial for the iterating character, a polynomial variable (lastUsed) that stores the polynomial for the iterating character if there is one, a character variable (temp) that stores a potential new variable with which to associate the resulting evaluation in the memory, a list of accumulators (coe, expo, power), an int (neg) and a boolean variable (zero) to record and eventually generate singleton polynomials. This finite state machine practically reads an expression string as operands, operators, and parenthesis, while looking out for old and new variables as well as equal signs. The method directly adds the polynomial, different operator functions and different parentheses Tokens, created or found, onto a LIFO queue of ArrayDeque framework for the PostfixConverter class to organize it into a sequence more decipherable for our purposes. 

I added 5 major features to this calculator beyond the criteria. First, the sorting function (sortPoly() in the Polynomial class) mentioned earlier arranges polynomial into descending order for easier read and processing.  Second, the calculator allows users to assign new polynomial values to the used variables. Third, the calculator allows users to access and alter the polynomial values associated with variables created from the other mode of the calculator, essentially providing a shared memory for the two modes. Forth, the calculator shows the other variables with equivalent values as the expression that is evaluated, and it perhaps could remind the user other similar calculations that was done before, or be used for checking the correction of its evaluation. Fifth, () and variables can be multiplied to the coefficient or operand right adjacent to them, meaning there is no need to input “7*a*b*(5+3)*(3-2)”, instead “7ab(5+3)(3-2)” would do just the same.

There are 2 major setbacks to this calculator. The most glaring limit of this calculator is that it has trouble dividing non-integers or doing incomplete divisions. Though the coefficient of the calculator is designed to take in a decimal value, my division function does not generate a quotient made with monomials constitute decimal numbers. Sometimes an integer could be even processed and stored as a double when they are multiplied, and eventually fail when called for division because they cannot be perfectly divided. This has caused many frustrating evaluation, and is worth diving in for a reconstruction. Another flaw of my calculator is that it does not take in exponent values that needs to be arithmetically evaluated, meaning if the exponent alone requires operation and has parenthesis, my calculator will not be able to produce the ideal result and will most likely fail. An example input such as 4x^(5+3) would not be passed in, and an input like 4x^5+3 will be evaluated as (4x^5)+(3), making two separate monomials. This is due to my initial set up when evaluating the coefficient and exponent values. My calculator does not take in strings of characters that represent numbers and then parses it using the parseDouble() method, and instead my finite state knows the number that expects to be one that constitutes the coefficient or the exponent. However, because I treat all parentheses the same way, I do not have states that are specifically set for the calculation of exponent values. Therefore, my exponent values cannot be enclosed exclusively in parentheses, or else they would be treated as distinct operands.
